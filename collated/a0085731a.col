//@author: a0085731a



	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Add.cpp
	 */

std::string Add::undo() {
	std::string feedback;

	TextStorage::getInstance()->deleteTask(_taskIndex);

	feedback = "Undo add: Deleted Task (" + typeConversions::intToString(_taskIndex) + ").";

	return feedback;
}

std::string Add::redo() {
	if (_taskIndex >= TextStorage::getInstance()->getNumberOfTasks()) {
		TextStorage::getInstance()->addTask(_addedTask);
	}
	else {
		TextStorage::getInstance()->addTaskAtSpecificPosition(_addedTask, _taskIndex);
	}

	std::string feedback = "Redo add: Added " + _addedTask->toString();

	return feedback;
}
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Add.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Date.cpp
	 */

bool Date::isDateDefined() {
	if (_day == 0) {
		return false;
	}
	if (_month == 0) {
		return false;
	}
	if (_year == 0) {
		return false;
	}
	return true;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Date.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Date.cpp
	 */

bool Date::setTime(int time) {
	if (time < 0 || time > 2359) {
		return false;
	}
	else {
		return true;
	}
}

void Date::setEndOfWeek() {
	_day += 7;

	int numDaysInMonth = timeDateInfo::getDaysInMonth(_month - 1, _year);

	if (_day > numDaysInMonth) {
		_month++;
		if (_month > 12) {
			_month = 1;
			_year++;
		}

		_day = _day - numDaysInMonth;
	}
}

void Date::setEndOfDay() {
	_time = 2359;
}
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Date.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Delete.cpp
	 */

// Delete.cpp
// Implementation of functions in the Delete class


#include "Delete.h"

// TODO Implement input formats 3

Delete::Delete() : Command() {
	_deletedCount = 0;
}

Delete::~Delete() {
}

void Delete::process(std::string argument) {
	if (support::isSpacesOnly(argument)) {
		throw exceptionInputInvalidSpacesOnly;
	}

	int numOfTasks = TextStorage::getInstance()->getNumberOfTasks();

	bool isProcessed = false;
	for (int i = 0; i < BEFOREKEYWORDSARRAYSIZE; i++) {
		int beforeKeywordPos = argument.find(BEFOREKEYWORDSARRAY[i]);
		if (beforeKeywordPos != std::string::npos) {
			if (isProcessed) {
				throw exceptionInputInvalidDelParams;
			}
			isProcessed = true;
			if (argument.find(BEFOREKEYWORDSARRAY[i]) != 0) {
				throw exceptionInputInvalidDelParams;
			}
			std::string dateString = argument.substr(BEFOREKEYWORDSARRAY[i].size());
			if(support::isSpacesOnly(dateString)) {
				throw exceptionInputInvalidSpacesOnly;
			}
			Date* date = new Date;
			if (!date->setDate(dateString)) {
				throw exceptionInputInvalidDateTimeAddEdit;
			}
			date->setTime(0);
			for (int j = 0; j < numOfTasks; j++) {
				Task* task = TextStorage::getInstance()->getTask(j);
				if (task->hasStartDate() && task->hasEndDate() || task->hasEndDate()) {
					if (support::checkDateBefore(task->getEndDate(), date)) {
						_deletedTasksIndexes.push_back(j + 1);
					}
				}
				else if (task->hasStartDate()) {
					if (support::checkDateBefore(task->getStartDate(), date)) {
						_deletedTasksIndexes.push_back(j + 1);
					}
				}
			}
		}
	}

	if (!isProcessed) {
		if (argument.find(ALLKEYWORD) != std::string::npos) {
			if (argument.find(ALLKEYWORD) > 0) {
				throw exceptionInputInvalidDelParams;
			}
			for (int i = 0; i < numOfTasks; i++) {
				_deletedTasksIndexes.push_back(i+1);
			}
		} 
		else {
			int nextSpacePos = argument.find(" ");
			while (nextSpacePos != std::string::npos) {
				std::string taskIndexString = argument.substr(0, nextSpacePos);
				if (!typeConversions::isNumber(taskIndexString)) {
					throw exceptionInputInvalidTaskIndex;
				}
				int taskIndex = typeConversions::stringToInt(taskIndexString);
				if (taskIndex < 1 || taskIndex > numOfTasks) {
					throw exceptionInputInvalidTaskIndex;
				}
				_deletedTasksIndexes.push_back(taskIndex);
				argument = argument.substr(nextSpacePos + 1);
				support::isSpacesOnly(argument);
				nextSpacePos = argument.find(" ");
			}

			if (!typeConversions::isNumber(argument)) {
				throw exceptionInputInvalidTaskIndex;
			}
			_deletedTasksIndexes.push_back(typeConversions::stringToInt(argument));
		}
	}

	std::sort(_deletedTasksIndexes.begin(), _deletedTasksIndexes.end());
	
	return;
}

std::string Delete::execute(std::string argument) {
	// Formats:
	// 1. Delete single task
	//    - delete 1
	// 2. Delete multiple tasks
	//    - delete 1 2 3
	// 3. Delete all tasks before date
	//    - delete before 22/12/14
	//    - delete .b 22/12/14

	std::string feedback = "Deleted task(s): ";

	process(argument);

	for (unsigned int i = 0; i < _deletedTasksIndexes.size(); i++) {
		_deletedTasks.push_back(TextStorage::getInstance()->getTask(_deletedTasksIndexes[i] - _deletedCount-1));
		if (TextStorage::getInstance()->deleteTask(_deletedTasksIndexes[i] - _deletedCount)) {
			_deletedCount++;
			feedback += "(" + typeConversions::intToString(_deletedTasksIndexes[i]) + ")";
			if (i < _deletedTasksIndexes.size() - 1) {
				feedback += ", ";
			}
			else {
				feedback += ".";
			}
		}
		else {
			ErrorLog::inputErrorLog("Unsuccessful delete, please check delete class.");
		}
	}

	return feedback;
}

std::string Delete::undo() {
	_deletedCount = 0;

	std::string feedback = "Undo delete: Added task(s): ";

	for (unsigned int i = 0; i < _deletedTasksIndexes.size(); i++) {
		if (_deletedTasksIndexes[i] >= TextStorage::getInstance()->getNumberOfTasks()) {
			TextStorage::getInstance()->addTask(_deletedTasks[i]);
		}
		else{
			TextStorage::getInstance()->addTaskAtSpecificPosition(_deletedTasks[i], _deletedTasksIndexes[i]);
		}
		feedback += "(" + typeConversions::intToString(_deletedTasksIndexes[i]) + ")";
		if (i < _deletedTasks.size() - 1) {
			feedback += ", ";
		}
		else {
			feedback += ".";
		}
	}

	return feedback;
}

std::string Delete::redo() {
	std::string feedback = "Redo delete: Deleted task(s): ";
	
	for (unsigned int i = 0; i < _deletedTasksIndexes.size(); i++) {
		if (TextStorage::getInstance()->deleteTask(_deletedTasksIndexes[i] - _deletedCount)) {
			_deletedCount++;
			feedback += "(" + typeConversions::intToString(_deletedTasksIndexes[i]) + ")";
			if (i < _deletedTasksIndexes.size() - 1) {
				feedback += ", ";
			}
			else {
				feedback += ".";
			}
		}
		else {
			ErrorLog::inputErrorLog("Unsuccessful delete, please check delete class.");
		}
	}

	return feedback;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Delete.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Delete.h
	 */

// Delete.h
// Subclass of Command; implements the delete function
#pragma once

#include "Command.h"
#include "typeConversions.h"
#include "TextStorage.h"
#include "Exceptions.h"
#include "support.h"

#include <vector>
#include <algorithm>

class Delete : public Command {
private:
	std::vector<int> _deletedTasksIndexes;
	std::vector<Task*> _deletedTasks;
	int _deletedCount;

	void process(std::string);

public:
	Delete();
	~Delete();
	std::string execute(std::string argument);
	std::string undo();
	std::string redo();
};
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Delete.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Done.cpp
	 */

// Done.cpp
// Implementation of functions in the Delete class

#include "Done.h"

Done::Done() : Command() {
}

Done::~Done() {
}

void Done::process(std::string argument) {
	if (support::isSpacesOnly(argument)) {
		throw exceptionInputInvalidSpacesOnly;
	}

	int numOfTasks = TextStorage::getInstance()->getNumberOfTasks();

	bool isProcessed = false;
	for (int i = 0; i < BEFOREKEYWORDSARRAYSIZE; i++) {
		int beforeKeywordPos = argument.find(BEFOREKEYWORDSARRAY[i]);
		if (beforeKeywordPos != std::string::npos) {
			if (isProcessed) {
				throw exceptionInputInvalidDoneParams;
			}
			isProcessed = true;
			if (argument.find(BEFOREKEYWORDSARRAY[i]) != 0) {
				throw exceptionInputInvalidDoneParams;
			}
			std::string dateString = argument.substr(BEFOREKEYWORDSARRAY[i].size());
			if (support::isSpacesOnly(dateString)) {
				throw exceptionInputInvalidSpacesOnly;
			}
			Date* date = new Date;
			if (!date->setDate(dateString)) {
				throw exceptionInputInvalidDateTimeAddEdit;
			}
			date->setTime(0);
			for (int j = 0; j < numOfTasks; j++) {
				Task* task = TextStorage::getInstance()->getTask(j);
				if (task->hasStartDate() && task->hasEndDate() || task->hasEndDate()) {
					if (support::checkDateBefore(task->getEndDate(), date)) {
						_doneTasksIndexes.push_back(j + 1);
					}
				}
				else if (task->hasStartDate()) {
					if (support::checkDateBefore(task->getStartDate(), date)) {
						_doneTasksIndexes.push_back(j + 1);
					}
				}
			}
		}
	}

	if (!isProcessed) {
		if (argument.find(ALLKEYWORD) != std::string::npos) {
			if (argument.find(ALLKEYWORD) > 0) {
				throw exceptionInputInvalidDoneParams;
			}
			for (int i = 0; i < numOfTasks; i++) {
				_doneTasksIndexes.push_back(i + 1);
			}
		}
		else {
			int nextSpacePos = argument.find(" ");
			while (nextSpacePos != std::string::npos) {
				std::string taskIndexString = argument.substr(0, nextSpacePos);
				if (!typeConversions::isNumber(taskIndexString)) {
					throw exceptionInputInvalidTaskIndex;
				}
				int taskIndex = typeConversions::stringToInt(taskIndexString);
				if (taskIndex < 1 || taskIndex > numOfTasks) {
					throw exceptionInputInvalidTaskIndex;
				}
				_doneTasksIndexes.push_back(taskIndex);
				argument = argument.substr(nextSpacePos + 1);
				support::isSpacesOnly(argument);
				nextSpacePos = argument.find(" ");
			}

			if (!typeConversions::isNumber(argument)) {
				throw exceptionInputInvalidTaskIndex;
			}
			_doneTasksIndexes.push_back(typeConversions::stringToInt(argument));
		}
	}

	std::sort(_doneTasksIndexes.begin(), _doneTasksIndexes.end());

	return;
}

std::string Done::execute(std::string argument) {
	// Formats:
	// 1. Done single task
	//    - done 1
	// 2. Done multiple tasks
	//    - done 1 2 3
	// 3. Done all tasks before date
	//    - done before 22/12/14
	//    - done .b 22/12/14

	std::string feedback = "Marked completed task(s): ";

	process(argument);

	for (unsigned int i = 0; i < _doneTasksIndexes.size(); i++) {
		if (TextStorage::getInstance()->getTask(_doneTasksIndexes[i] - 1) != NULL) {
			_doneTasks.push_back(TextStorage::getInstance()->getTask(_doneTasksIndexes[i] - 1));
			TextStorage::getInstance()->getTask(_doneTasksIndexes[i] - 1)->done();
			feedback += "(" + typeConversions::intToString(_doneTasksIndexes[i]) + ")";
			if (i < _doneTasksIndexes.size() - 1) {
				feedback += ", ";
			}
			else {
				feedback += ".";
			}
		}
		else {
			ErrorLog::inputErrorLog("Unsuccessful done, please check done class.");
			assert(TextStorage::getInstance()->getTask(_doneTasksIndexes[i] - 1) != NULL);
		}
	}

	return feedback;
}

std::string Done::undo() {
	std::string feedback = "Undo done: Marked incomplete task(s): ";

	for (unsigned int i = 0; i < _doneTasks.size(); i++) {
		_doneTasks[i]->undone();
		feedback += "(" + typeConversions::intToString(_doneTasksIndexes[i]) + ")";
		if (i < _doneTasksIndexes.size() - 1) {
			feedback += ", ";
		}
		else {
			feedback += ".";
		}
	}

	return feedback;
}

std::string Done::redo() {
	std::string feedback = "Redo done: Marked complete task(s): ";

	for (unsigned int i = 0; i < _doneTasks.size(); i++) {
		_doneTasks[i]->done();
		feedback += "(" + typeConversions::intToString(_doneTasksIndexes[i]) + ")";
		if (i < _doneTasksIndexes.size() - 1) {
			feedback += ", ";
		}
		else {
			feedback += ".";
		}
	}

	return feedback;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Done.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Done.h
	 */

// Done.h
// Subclass of Command; implements the done function

#pragma once

#include "Command.h"
#include "typeConversions.h"
#include "TextStorage.h"
#include "Exceptions.h"
#include "support.h"

#include <vector>
#include <algorithm>

class Done : public Command {
private:
	std::vector<int> _doneTasksIndexes;
	std::vector<Task*> _doneTasks;

	void process(std::string);
	bool checkDateBefore(Date*, Date*);

public:
	Done();
	~Done();
	std::string execute(std::string argument);
	std::string undo();
	std::string redo();
};
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Done.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Edit.cpp
	 */

void Edit::process(std::string userInput) {
	if (support::isSpacesOnly(userInput)) {
		throw exceptionInputInvalidSpacesOnly;
	}

	furnishTaskToBeEdited(userInput);

	furnishEditContents(userInput);
}

void Edit::furnishTaskToBeEdited(std::string &userInput) {
	if (userInput == "") {
		throw exceptionInputMissingEditTaskIndexAndParams;
	}

	_taskIndexToBeEdited = extractTaskIndex(userInput);

	Task* originalTask = TextStorage::getInstance()->getTask(_taskIndexToBeEdited-1);

	if(originalTask == NULL) {
		throw exceptionInputInvalidTaskIndex;
	}

	_originalTask = new Task;
	_originalTask->setDescription(originalTask->getDescription());
	if (originalTask->getStartDate() != NULL) {
		Date* originalStartDate = new Date(originalTask->getStartDate()->getDay(), originalTask->getStartDate()->getMonth(), originalTask->getStartDate()->getYear(), originalTask->getStartDate()->getTime());
		_originalTask->setStartDate(originalStartDate);
	}	
	if (originalTask->getEndDate() != NULL) {
		Date* originalEndDate = new Date(originalTask->getEndDate()->getDay(), originalTask->getEndDate()->getMonth(), originalTask->getEndDate()->getYear(), originalTask->getEndDate()->getTime());
		_originalTask->setEndDate(originalEndDate);
	}
	_originalTask->setLocation(originalTask->getLocation());

	_editedTask = originalTask;

	return;
}

int Edit::extractTaskIndex(std::string &userInput){
	int spacePosition = userInput.find(" ");

	if (spacePosition == std::string::npos) {
		throw exceptionInputMissingEditParams;
	}

	if (!typeConversions::isNumber(userInput.substr(0,spacePosition))) {
		throw exceptionInputInvalidTaskIndex;
	}

	std::string taskIndexToBeEditedString = userInput.substr(0, spacePosition);

	userInput = userInput.substr(spacePosition + 1);

	int taskIndexToBeEdited = typeConversions::stringToInt(taskIndexToBeEditedString);

	return taskIndexToBeEdited;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Edit.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Edit.cpp
	 */

bool Edit::checkDateTimeInputIsTime(std::string input) {
	if (input.size() == LENGTH_TIMEINPUT) {
		return true;
	}
	else {
		return false;
	}
}

bool Edit::checkDateTimeInputIsDateTime(std::string input) {
	if (input.size()>LENGTH_TIMEINPUT && input.substr(input.size() - LENGTH_TIMEINPUT).find_first_not_of(INTS) == std::string::npos) {
		return true;
	}
	else {
		return false;
	}
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Edit.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Edit.cpp
	 */

int Edit::getEditedTaskIndex() {
	return _taskIndexToBeEdited;
}

std::string Edit::undo() {
	std::string feedback;

	Task* temp = new Task();
	
	*temp = *_editedTask;

	*_editedTask = *_originalTask;

	*_originalTask = *temp;

	feedback = prepareFeedback();

	return feedback;
}

std::string Edit::redo() {
	std::string feedback;

	Task* temp = new Task();

	*temp = *_editedTask;

	*_editedTask = *_originalTask;

	*_originalTask = *temp;

	feedback = prepareFeedback();

	return feedback;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Edit.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Edit.h
	 */

// Edit.h
// Subclass of Command; implements the edit function


/**********************************************************************************************************
Name: Edit
Type: Class
Purpose: Child class of Command parent class.
Responsible for executing editing of task in tasks database text file, when its execute API
is called by ComCalManager class.
**********************************************************************************************************/

#pragma once

#include "Command.h"
#include "keywords.h"
#include "timeDateInfo.h"
#include "support.h"
#include "TextStorage.h"
#include "typeConversions.h"
#include "Exceptions.h"

class Edit : public Command {
private:
	/****************************************************************************************************
	Name: _attributeKeywords
	Type: Vector of strings attribute
	Purpose: Holds recognised attribute keywords
	****************************************************************************************************/
	std::vector<std::string> _attributeKeywords;
	
	/****************************************************************************************************
	Type: Private attributes
	Purpose: Hold characteristics of edit object, including task index to be edited, attributes and contents to be edited,
	the original task object and the task object after editing.
	****************************************************************************************************/
	int _taskIndexToBeEdited;
	std::vector<std::string> _attributesToBeEdited;
	std::vector<std::string> _contentsToBeEdited;
	Task* _originalTask;
	Task* _editedTask;

	/****************************************************************************************************
	Name: extractTaskIndex
	Type: Method
	Purpose: Extracts and returns task index to be edited from input reference string. Throws missing 
	edit parameters exception if no space is read in input reference string. Removes task index read from
	input reference string.
	****************************************************************************************************/
	int extractTaskIndex(std::string&);
	
	/****************************************************************************************************
	Name: process
	Type: Method
	Purpose: Processes input string to obtain specified task index to be edited, attribute codes and 
	new content for each attribute to be edited and furnishes the respect vector of string private
	attributes.
	****************************************************************************************************/
	void process(std::string);

	/****************************************************************************************************
	Name: furnishTaskToBeEdited
	Type: Method
	Purpose: Furnishes _orignalTask and _editedTask private attributes with specified task index to be 
	edited from input reference string, and removes the this task index from the input reference string.
	****************************************************************************************************/
	void furnishTaskToBeEdited(std::string&);
	
	/****************************************************************************************************
	Name: furnishEditContents
	Type: Method
	Purpose: Furnishes remaining private attributes with specifications from input reference string, and
	removes these from the input reference string.
	****************************************************************************************************/
	void furnishEditContents(std::string&);
	
	/****************************************************************************************************
	Name: checkDateTimeInputIsTime
	Type: Method
	Purpose: Checks and returns true if input string is a time input of 4 integers, false otherwise.
	****************************************************************************************************/
	bool checkDateTimeInputIsTime(std::string);

	/****************************************************************************************************
	Name: checkDateTimeInputIsTime
	Type: Method
	Purpose: Checks and returns true if input string is a date time input with last 4 characters being
	integers, false otherwise.
	****************************************************************************************************/
	bool checkDateTimeInputIsDateTime(std::string);

	/****************************************************************************************************
	Name: prepareFeedback
	Type: Method
	Purpose: Prepares and returns edit feedback string upon successful edit execution.
	****************************************************************************************************/
	std::string prepareFeedback();
public:
	Edit();
	~Edit();

	/****************************************************************************************************
	Name: execute
	Type: Method
	Purpose: Public API for ComCalManager class to call to execute edit action.
	****************************************************************************************************/
	std::string execute(std::string argument);

	/****************************************************************************************************
	Name: undo
	Type: Method
	Purpose: Public API for ComCalManager class to call to undo edit action.
	****************************************************************************************************/
	std::string undo();

	/****************************************************************************************************
	Name: redo
	Type: Method
	Purpose: Public API for ComCalManager class to call to redo edit action.
	****************************************************************************************************/
	std::string redo();

	/****************************************************************************************************
	Name: getEditedTaskIndex
	Type: Method
	Purpose: (for unit tests to call) Returns edited task's index.
	****************************************************************************************************/
	int getEditedTaskIndex();
};
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Edit.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\keywords.h
	 */

// Strings for possible user inputs
static const std::string INPUT_TODO = "todo";
static const int TODO_CODE = 1;
static const std::string INPUT_DONE = "done";
static const int DONE_CODE = 2;
static const std::string INPUT_TIMED = "timed";
static const std::string DEADLINED_TASK = "deadline";
static const std::string FLOATING_TASKS = "floating";
static const std::string INPUT_PARTIAL = "partial";
static const std::string ALL_TASKS = "all";
static const int ALL_CODE = 3;

//Attribute keywords constant string and index int declarations:
static const int ATTRIBUTEKEYWORDSARRAYSIZE = 4;
static const std::string ATTRIBUTEKEYWORDSARRAY[ATTRIBUTEKEYWORDSARRAYSIZE] = { " .d ", " .s ", " .e ", " .l " };
static const int INDEX_DESCRIPTION = 0;
static const int INDEX_STARTDATETIME = 1;
static const int INDEX_ENDDATETIME = 2;
static const int INDEX_LOCATION = 3;

//Delete before certain date/time command keywords:
static const int BEFOREKEYWORDSARRAYSIZE = 2;
static const std::string BEFOREKEYWORDSARRAY[BEFOREKEYWORDSARRAYSIZE] = { ".b ", "before " };
static const std::string ALLKEYWORD = "all";

//Integer string:
static const std::string INTS = "0123456789";

//Attribute constant string declarations:
static const std::string DESCRIPTION = "[D]";
static const std::string STARTDATETIME = "[S]";
static const std::string STARTDATE = "[S-D]";
static const std::string STARTTIME = "[S-T]";
static const std::string ENDDATETIME = "[E]";
static const std::string ENDDATE = "[E-D]";
static const std::string ENDTIME = "[E-T]";
static const std::string DEADLINE = "[DL]";
static const std::string DEADLINEDATE = "[DL-D]";
static const std::string DEADLINETIME = "[DL-T]";
static const std::string LOCATION = "[L]";

//Search-related constant declarations:
static const int SEARCHCONDITIONKEYWORDSARRAYSIZE = 3;
static const std::string SEARCHCONDITIONKEYWORDSARRAY[SEARCHCONDITIONKEYWORDSARRAYSIZE] = { " and ", " or ", " not " };
static const int INDEX_AND = 0;
static const int INDEX_OR = 1;
static const int INDEX_NOT = 2;
static const int INDEX_WILDCARD = -1;
static const std::string SEARCHDATETIMERANGESTART = "from ";
static const std::string SEARCHDATETIMERANGEEND = " to ";
static const std::string AND = "AND";
static const std::string OR = "OR";
static const std::string NOT = "EXCLUDING";

//Task type constant declarations:
static const int TASKTYPECODE_FLOATING = 1;
static const int TASKTYPECODE_DEADLINE = 2;
static const int TASKTYPECODE_PARTIALTIMED = 3;
static const int TASKTYPECODE_TIMED = 4;
static const std::string TASKTYPE_FLOATING = "FLOATING";
static const std::string TASKTYPE_PARTIALTIMED = "PARTIAL-TIMED";
static const std::string TASKTYPE_TIMED = "TIMED";

//Task type constant string declarations:
static const std::string TASKTYPE_EVENT = "EVENT";
static const std::string TASKTYPE_DEADLINE = "DEADLINE";
static const std::string TASKTYPE_TODO = "TO-DO";
static const std::string TASKS = "Tasks";

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\keywords.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\keywords.h
	 */

//Time and date info
static const int MAX_ASCTIME_S = 26;
static const int DAYS_IN_WEEK = 7;
static const int MONTHS_IN_YEAR = 12;
static const int MAX_DAYS_IN_MONTH = 31;
static const int NUM_BLOCKS_IN_CALENDAR = 42;
static const int SECONDS_IN_DAY = 24 * 60 * 60;
static const int SECONDS_IN_WEEK = 7 * SECONDS_IN_DAY;

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\keywords.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\keywords.h
	 */

//Input error messages here
static const std::string GET_MONTH_STR_ERROR = "Integer passed outside the boundaries of 0 and 11\n";
static const std::string TODO_DONE_INPUT_ERROR = "Invalid todo/done input: Please input either 'todo' or 'done'";
static const std::string GUI_UPDATE_ERROR = "isShowMonth and/or isShowDayTaskSearch was not flagged\n";
static const std::string NO_TASKS_IN_VECTOR = "No tasks contained in _todoTask vector\n";
static const std::string INVALID_COMMAND = "This is not a valid command\n";
static const std::string INVALID_MONTH_INPUT = "Invalid month input";
static const std::string INVALID_SHOW_INPUT = "Input arguments invalid for show command";
static const std::string INVALID_DATE_INPUT = "Invalid date input. Proper format: 'dd/mm/yyyy' , 'today', 'yesterday' , 'tomorrow' , 'monday' , tuesday' etc.";
static const std::string INVALID_NEXT_INPUT = "Please input in the format 'next month' or 'next week'";
static const std::string INVALID_YEAR_ERROR = "Please input a year above 1900 in the format YYYY eg. 2016";
static const std::string INVALID_WEEK_INPUT = "Please input in the format: 'show week' or 'show week todo' or 'show week done' or 'show next week' or 'show week DD/MM/YYYY' or 'show week monday/tuesday/etc'";


	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\keywords.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Search.cpp
	 */

//Search.cpp
//Implementation of functions in the Search class

#include "Search.h"
#include "ComCalManager.h"
#include "keywords.h"

static const std::string SYSTEMERROR_UNRECOGNIZEDSEARCHATTRIBUTEPASSED = "System error: Unrecognized search attribute code stored in _attributeToSearch private attribute of SearchCondition object. Search attribute code read = ";
static const std::string SYSTEMERROR_UNRECOGNIZEDSEARCHCONDITIONPASSED = "System error: Unrecognized search condition code stored in SearchCondition object in _searchConditions private attribute of Search class. Search condition code read = ";

Search::Search() : Command() {
}

Search::~Search() {
}

bool Search::isResultWildcardSearch(Task* taskUnderExam, std::string searchContents) {
	searchContents = searchContents.substr(1);
	if (taskUnderExam->getDescription().find(searchContents) == std::string::npos && taskUnderExam->getLocation().find(searchContents) == std::string::npos) {
		return false;
	}
	else {
		return true;
	}
}

bool Search::isResultDescriptionSearch(Task* taskUnderExam, std::string searchContents) {
	if (taskUnderExam->getDescription().find(searchContents) == std::string::npos) {
		return false;
	}
	else {
		return true;
	}
}

bool Search::isResultLocationSearch(Task* taskUnderExam, std::string searchContents) {
	if (taskUnderExam->getLocation().find(searchContents) == std::string::npos) {
		return false;
	}
	else {
		return true;
	}
}

bool Search::isResultDateSearch(Date* taskDate, std::string searchContents) {
	Date* timeRangeStart = new Date();
	Date* timeRangeEnd = new Date();
	//Check for from and to specification
	int timeRangeStartPos = searchContents.find(SEARCHDATETIMERANGESTART);
	int timeRangeEndPos = searchContents.find(SEARCHDATETIMERANGEEND);
	if (timeRangeStartPos > 0) {
		throw exceptionInputInvalidDateTimeShowSearch;
	}
	else if (timeRangeStartPos != std::string::npos&&timeRangeEndPos == std::string::npos) {
		throw exceptionInputInvalidTimeRangeEndMissing;
	}
	else if (timeRangeStartPos == std::string::npos&&timeRangeEndPos != std::string::npos) {
		throw exceptionInputInvalidTimeRangeStartMissing;
	}
	else if (timeRangeStartPos != std::string::npos&&timeRangeEndPos != std::string::npos) {
		std::string timeRangeStartString = searchContents.substr(SEARCHDATETIMERANGESTART.size(), timeRangeEndPos - SEARCHDATETIMERANGESTART.size());
		if (!timeRangeStart->setDate(timeRangeStartString)) {
			throw exceptionInputInvalidDateTimeShowSearch;
		}
		if (timeRangeStart->getTime() == NULL) {
			timeRangeStart->setTime(0);
		}
		std::string timeRangeEndString = searchContents.substr(timeRangeEndPos + SEARCHDATETIMERANGEEND.size());
		if (!timeRangeEnd->setDate(timeRangeEndString)) {
			throw exceptionInputInvalidDateTimeShowSearch;
		}
		if (timeRangeEnd->getTime() == NULL) {
			timeRangeEnd->setTime(2359);
		}
	}
	else {
		//No from and to specification
		if (searchContents.find(DATE_WEEK) != std::string::npos) {
			if (!timeRangeStart->setDate(searchContents)) {
				throw exceptionInputInvalidDateTimeShowSearch;
			}
			timeRangeEnd->setDate(searchContents);
			timeRangeEnd->setEndOfWeek();
		}
		else {
			if (!timeRangeStart->setDate(searchContents)) {
				throw exceptionInputInvalidDateTimeShowSearch;
			}
			timeRangeEnd->setDate(searchContents);
			timeRangeEnd->setEndOfDay();
		}
	}
	
	bool isResult = support::isDateWithinTimeRange(taskDate, timeRangeStart, timeRangeEnd);

	return isResult;
}

std::string Search::execute(std::string argument) {
	process(argument);

	int numOfTasks = TextStorage::getInstance()->getNumberOfTasks();
	for (unsigned int i = 0; i < _searchConditions.size(); i++) {
		std::vector<int> attributesToSearch = _searchConditions[i].getAttributesToSearch();
		std::vector<std::vector<std::string>> contentsToSearch = _searchConditions[i].getContentsToSearch();
		switch (_searchConditions[i].getCondition()) {
		case INDEX_AND:
			if (!_searchResults.empty()) {
				unsigned int j = 0;
				while (j < _searchResults.size()) {
					Task* taskUnderExam = _searchResults[j];
					for (unsigned int k = 0; k < attributesToSearch.size(); k++) {
						switch (attributesToSearch[k]) {
						case INDEX_WILDCARD:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (!isResultWildcardSearch(taskUnderExam, contentsToSearch[k][l])) {
									_searchResults.erase(_searchResults.begin() + j);
								}
								else {
									j++;
								}
							}
							break;
						case INDEX_DESCRIPTION:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (!isResultDescriptionSearch(taskUnderExam, contentsToSearch[k][l])) {
									_searchResults.erase(_searchResults.begin() + j);
								}
								else {
									j++;
								}
							}
							break;
						case INDEX_STARTDATETIME:
							if (taskUnderExam->hasStartDate()) {
								for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
									if (!isResultDateSearch(taskUnderExam->getStartDate(), contentsToSearch[k][l])) {
										_searchResults.erase(_searchResults.begin() + j);
									}
									else {
										j++;
									}
								}
							}
							else {
								_searchResults.erase(_searchResults.begin() + j);
							}
							break;
						case INDEX_ENDDATETIME:
							if (taskUnderExam->hasEndDate()) {
								for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
									if (!isResultDateSearch(taskUnderExam->getEndDate(), contentsToSearch[k][l])) {
										_searchResults.erase(_searchResults.begin() + j);
									}
									else {
										j++;
									}
								}
							}
							else {
								_searchResults.erase(_searchResults.begin() + j);
							}
							break;
						case INDEX_LOCATION:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (!isResultLocationSearch(taskUnderExam, contentsToSearch[k][l])) {
									_searchResults.erase(_searchResults.begin() + j);
								}
								else {
									j++;
								}
							}
							break;
						default:
							ErrorLog::inputErrorLog(SYSTEMERROR_UNRECOGNIZEDSEARCHATTRIBUTEPASSED + typeConversions::intToString(attributesToSearch[j]));
						}
					}
				}
			}
			break;
		case INDEX_OR:
			for (int j = 0; j < numOfTasks; j++) {
				bool isInResults = false;
				if (!_searchResults.empty()) {
					for (unsigned int k = 0; k < _searchResults.size(); k++) {
						if (_searchResults[k] == TextStorage::getInstance()->getTask(j)) {
							isInResults = true;
						}
					}
				}
				if (!isInResults) {
					Task* taskUnderExam = TextStorage::getInstance()->getTask(j);
					bool satisfySearch = true;
					for (unsigned int k = 0; k < attributesToSearch.size() && satisfySearch; k++) {
						switch (attributesToSearch[k]) {
						case INDEX_WILDCARD:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (!isResultWildcardSearch(taskUnderExam, contentsToSearch[k][l])) {
									satisfySearch = false;
								}
							}
							break;
						case INDEX_DESCRIPTION:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (!isResultDescriptionSearch(taskUnderExam, contentsToSearch[k][l])) {
									satisfySearch = false;
								}
							}
							break;
						case INDEX_STARTDATETIME:
							if (taskUnderExam->hasStartDate()) {
								for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
									if (!isResultDateSearch(taskUnderExam->getStartDate(), contentsToSearch[k][l])) {
										satisfySearch = false;
									}
								}
							}
							else {
								satisfySearch = false;
							}
							break;
						case INDEX_ENDDATETIME:
							if (taskUnderExam->hasEndDate()) {
								for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
									if (!isResultDateSearch(taskUnderExam->getEndDate(), contentsToSearch[k][l])) {
										satisfySearch = false;
									}
								}
							}
							else {
								satisfySearch = false;
							}
							break;
						case INDEX_LOCATION:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (!isResultLocationSearch(taskUnderExam, contentsToSearch[k][l])) {
									satisfySearch = false;
								}
							}
							break;
						default:
							ErrorLog::inputErrorLog(SYSTEMERROR_UNRECOGNIZEDSEARCHATTRIBUTEPASSED + typeConversions::intToString(attributesToSearch[k]));
						}
					}

					if (satisfySearch) {
						_searchResults.push_back(taskUnderExam);
					}
				}
			}
			break;
		case INDEX_NOT:
			if (!_searchResults.empty()) {
				unsigned int j = 0;
				while (j < _searchResults.size()) {
					Task* taskUnderExam = _searchResults[j];
					for (unsigned int k = 0; k < attributesToSearch.size(); k++) {
						switch (attributesToSearch[k]) {
						case INDEX_WILDCARD:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (isResultWildcardSearch(taskUnderExam, contentsToSearch[k][l])) {
									_searchResults.erase(_searchResults.begin() + j);
								}
								else {
									j++;
								}
							}
							break;
						case INDEX_DESCRIPTION:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (isResultDescriptionSearch(taskUnderExam, contentsToSearch[k][l])) {
									_searchResults.erase(_searchResults.begin() + j);
								}
								else {
									j++;
								}
							}
							break;
						case INDEX_STARTDATETIME:
							if (taskUnderExam->hasStartDate()) {
								for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
									if (isResultDateSearch(taskUnderExam->getStartDate(), contentsToSearch[k][l])) {
										_searchResults.erase(_searchResults.begin() + j);
									}
									else {
										j++;
									}
								}
							}
							else {
								j++;
							}
							break;
						case INDEX_ENDDATETIME:
							if (taskUnderExam->hasEndDate()) {
								for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
									if (isResultDateSearch(taskUnderExam->getEndDate(), contentsToSearch[k][l])) {
										_searchResults.erase(_searchResults.begin() + j);
									}
									else {
										j++;
									}
								}
							}
							else {
								j++;
							}
							break;
						case INDEX_LOCATION:
							for (unsigned int l = 0; l < contentsToSearch[k].size(); l++) {
								if (isResultLocationSearch(taskUnderExam, contentsToSearch[k][l])) {
									_searchResults.erase(_searchResults.begin() + j);
								}
								else {
									j++;
								}
							}
							break;
						default:
							ErrorLog::inputErrorLog(SYSTEMERROR_UNRECOGNIZEDSEARCHATTRIBUTEPASSED + typeConversions::intToString(attributesToSearch[j]));
						}
					}
				}
			}
			break;
		default:
			ErrorLog::inputErrorLog(SYSTEMERROR_UNRECOGNIZEDSEARCHCONDITIONPASSED + typeConversions::intToString(_searchConditions[i].getCondition()));
		}
	}

	for (int i = 0; i < numOfTasks; i++) {
		TextStorage::getInstance()->getTask(i)->hide();
	}

	for (unsigned int i = 0; i < _searchResults.size(); i++) {
		_searchResults[i]->display();
	}

	std::string feedback = prepareFeedback();
	ComCalManager::getInstance()->setSideBarTitle(SEARCH_RESULTS_TITLE);

	return feedback;
}

void Search::process(std::string argument) {
	std::string previousContents;
	int nextConditionCode;
	int nextConditionPos = getNextConditionAndPosAndPreviousContents(argument, nextConditionCode, previousContents);
	int conditionIndex = 1;
	SearchCondition firstSearchCondition(INDEX_OR);
	_searchConditions.push_back(firstSearchCondition);
	while (nextConditionPos!=std::string::npos) {
		SearchCondition nextSearchCondition(nextConditionCode);
		_searchConditions.push_back(nextSearchCondition);
		_searchConditions[conditionIndex-1].setContents(previousContents);
		nextConditionPos = getNextConditionAndPosAndPreviousContents(argument, nextConditionCode, previousContents);
		conditionIndex++;
	}
	_searchConditions[conditionIndex - 1].setContents(argument);

	return;
}

int Search::getNextConditionAndPosAndPreviousContents(std::string& input, int& conditionCode, std::string& previousContents) {
	std::vector<int> conditionPosVect;
	std::vector<int> conditionCodeVect;
	std::string inputLowerCase = typeConversions::toLowerCase(input);

	for (int i = 0; i < SEARCHCONDITIONKEYWORDSARRAYSIZE; i++) {
		int conditionPos = inputLowerCase.find(SEARCHCONDITIONKEYWORDSARRAY[i]);
		if (conditionPos != std::string::npos) {
			conditionPosVect.push_back(conditionPos);
			conditionCodeVect.push_back(i);
		}
	}

	if (conditionPosVect.empty()) {
		return std::string::npos;
	}

	int conditionPos = conditionPosVect[0];
	conditionCode = conditionCodeVect[0];
	for (unsigned int i = 1; i < conditionPosVect.size(); i++) {
		if (conditionPosVect[i] < conditionPos) {
			conditionPos = conditionPosVect[i];
			conditionCode = conditionCodeVect[i];
		}
	}

	previousContents = input.substr(0,conditionPos);
	if (support::isSpacesOnly(previousContents)){
		throw exceptionInputInvalidSpacesOnly;
	}
	input = input.substr(conditionPos + SEARCHCONDITIONKEYWORDSARRAY[conditionCode].size());

	return conditionPos;
}

std::string Search::prepareFeedback() {
	std::string feedback = "Executed search of: ";

	for (unsigned int i = 0; i < _searchConditions.size(); i++) {
		if (i != 0) {
			switch (_searchConditions[i].getCondition()) {
			case INDEX_AND:
				feedback += " " + AND + " (";
				break;
			case INDEX_OR:
				feedback += " " + OR + " (";
				break;
			case INDEX_NOT:
				feedback += " " + NOT + " (";
			}
		}
		else {
			feedback += "(";
		}
		for (unsigned int j = 0; j < _searchConditions[i].getAttributesToSearch().size(); j++) {
			switch (_searchConditions[i].getAttributesToSearch()[j]) {
			case INDEX_DESCRIPTION:
				feedback += " " + DESCRIPTION + ": ";
				break;
			case INDEX_STARTDATETIME:
				feedback += " " + STARTDATETIME + ": ";
				break;
			case INDEX_ENDDATETIME:
				feedback += " " + ENDDATETIME + ": ";
				break;
			case INDEX_LOCATION:
				feedback += " " + LOCATION + ": ";
				break;
			}
			for (unsigned int k = 0; k < _searchConditions[i].getContentsToSearch()[j].size(); k++) {
				switch (_searchConditions[i].getAttributesToSearch()[j]) {
				case INDEX_DESCRIPTION:
					feedback += "\"";
					break;
				case INDEX_LOCATION:
					feedback += "\"";
					break;
				}
				feedback += _searchConditions[i].getContentsToSearch()[j][k];
				switch (_searchConditions[i].getAttributesToSearch()[j]) {
				case INDEX_DESCRIPTION:
					feedback += "\"";
					break;
				case INDEX_LOCATION:
					feedback += "\"";
					break;
				}
				if (k < _searchConditions[i].getContentsToSearch()[j].size() - 1) {
					feedback += ", ";
				}
			}
			if (j < _searchConditions[i].getAttributesToSearch().size() - 1) {
				feedback += ";";
			}
		}
		feedback += " )";
	}

	return feedback;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Search.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Search.h
	 */

//Search.h
//Subclass of Command; implements the search function

#pragma once

#include "Command.h"
#include "SearchCondition.h"
#include "TextStorage.h"
#include "Task.h"
#include "Date.h"
#include "support.h"

#include <algorithm>

class Search : public Command {
private:
	/****************************************************************************************************
	Name: _searchConditions
	Type: Vector of SearchCondition objects attribute
	Purpose: Holds search contents in the form of SearchCondition objects containing their associated
	search condition int code, attributes and contents.
	****************************************************************************************************/
	std::vector<SearchCondition>_searchConditions;

	/****************************************************************************************************
	Name: _searchResults
	Type: Vector of Task object pointers attribute
	Purpose: Holds search results.
	****************************************************************************************************/
	std::vector<Task*>_searchResults;

	/****************************************************************************************************
	Name: process
	Type: Method
	Purpose: Processes input string to furnish _searchConditions private attribute.
	****************************************************************************************************/
	void process(std::string);

	/****************************************************************************************************
	Name: getNextConditionAndPos
	Type: Method
	Purpose: Processes first input reference string to obtain next condition's position and index code,
	as well as previous condition's contents, returning the position as int, assigning the index code 
	to second input reference int and previous condition's contents to third input reference string, and 
	removing portion of the first input reference string from its start to the end of the condition read.
	****************************************************************************************************/
	int getNextConditionAndPosAndPreviousContents(std::string&, int&, std::string&);

	/****************************************************************************************************
	Name: prepareFeedback
	Type: Method
	Purpose: Prepares and returns feedback string for successful search execution.
	****************************************************************************************************/
	std::string prepareFeedback();

	/****************************************************************************************************
	Name: isResultDescriptionSearch
	Type: Method
	Purpose: Checks and returns true if Task pointer satisfies input string description search, false
	otherwise.
	****************************************************************************************************/
	bool isResultDescriptionSearch(Task*, std::string);

	/****************************************************************************************************
	Name: isResultDateSearch
	Type: Method
	Purpose: Checks and returns true if Date pointer satisfies input string start date/time search, false
	otherwise.
	****************************************************************************************************/
	bool isResultDateSearch(Date*, std::string);

	/****************************************************************************************************
	Name: isResultLocationSearch
	Type: Method
	Purpose: Checks and returns true if Task pointer satisfies input string location search, false
	otherwise.
	****************************************************************************************************/
	bool isResultLocationSearch(Task*, std::string);

	/****************************************************************************************************
	Name: isResultWildcardSearch
	Type: Method
	Purpose: Checks and returns true if Task pointer satisfies input string wildcard (description and 
	location) search, false otherwise.
	****************************************************************************************************/
	bool isResultWildcardSearch(Task*, std::string);

public:
	Search();
	~Search();

	/****************************************************************************************************
	Name: execute
	Type: Method
	Purpose: Executes search command with input string and returns feedback string.
	****************************************************************************************************/
	std::string execute(std::string argument);
};
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Search.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\SearchCondition.cpp
	 */

// SearchCondition.cpp
// Implementation of functions in SearchCondition class

#include "SearchCondition.h"

SearchCondition::SearchCondition(int condition) {
	_attributeKeywords.assign(ATTRIBUTEKEYWORDSARRAY, ATTRIBUTEKEYWORDSARRAY + ATTRIBUTEKEYWORDSARRAYSIZE);

	_condition = condition;
}

SearchCondition::~SearchCondition() {
}

void SearchCondition::setContents(std::string contents) {
	contents = " " + contents;
	std::vector<std::vector<std::string>> keywordsAndParams = support::extractParamsForKeywords(contents, _attributeKeywords);

	if (contents != "") {
		_attributesToSearch.push_back(INDEX_WILDCARD);
		contents = contents.substr(1);
		std::vector<std::string> contentsToSearch;
		contentsToSearch.push_back(contents);
		_contentsToSearch.push_back(contentsToSearch);
	}
	for (unsigned int i = 0; i < keywordsAndParams.size(); i++) {
		if (!keywordsAndParams[i].empty()) {
			switch (i) {
			case INDEX_DESCRIPTION:
				_attributesToSearch.push_back(INDEX_DESCRIPTION);
				break;
			case INDEX_STARTDATETIME:
				_attributesToSearch.push_back(INDEX_STARTDATETIME);
				break;
			case INDEX_ENDDATETIME:
				_attributesToSearch.push_back(INDEX_ENDDATETIME);
				break;
			case INDEX_LOCATION:
				_attributesToSearch.push_back(INDEX_LOCATION);
				break;
			}

			for (unsigned int j = 0; j < keywordsAndParams[i].size(); j++) {
				if (keywordsAndParams[i][j] == "") {
					throw exceptionInputMissingAttributeParam;
				}
			}
			_contentsToSearch.push_back(keywordsAndParams[i]);
		}
	}
}

int SearchCondition::getCondition() {
	return _condition;
}

std::vector<int> SearchCondition::getAttributesToSearch() {
	return _attributesToSearch;
}

std::vector<std::vector<std::string>> SearchCondition::getContentsToSearch() {
	return _contentsToSearch;
}
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\SearchCondition.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\SearchCondition.h
	 */

// SearchCondition.h
// Class to hold search condition information

#pragma once

#include "support.h"

#include <vector>
#include <string>

class SearchCondition {
private:
	/****************************************************************************************************
	Name: _condition
	Type: int
	Purpose: Holds condition int code of this object.
	****************************************************************************************************/
	int _condition;
	
	/****************************************************************************************************
	Name: _attributeKeywords
	Type: Vector of strings attribute
	Purpose: Holds recognised attribute keywords.
	****************************************************************************************************/
	std::vector<std::string> _attributeKeywords;

	/****************************************************************************************************
	Name: _attributesToSearch
	Type: Vector of strings attribute
	Purpose: Holds attributes to search.
	****************************************************************************************************/
	std::vector<int> _attributesToSearch;

	/****************************************************************************************************
	Name: _contentsToSearch
	Type: Vector of strings attribute
	Purpose: Holds contents of each corresponding index attribute to search.
	****************************************************************************************************/
	std::vector<std::vector<std::string>> _contentsToSearch;

public:
	/****************************************************************************************************
	Name: SearchCondition
	Type: Constructor
	Purpose: Constructs search condition object with associated condition int code.
	****************************************************************************************************/
	SearchCondition(int);
	~SearchCondition();

	/****************************************************************************************************
	Name: setContents
	Type: Method
	Purpose: Furnish attributes and contents to search with input string.
	****************************************************************************************************/
	void setContents(std::string);

	/****************************************************************************************************
	Name: getCondition
	Type: Method
	Purpose: Returns condition int code.
	****************************************************************************************************/
	int getCondition();

	/****************************************************************************************************
	Name: getAttributesToSearch
	Type: Method
	Purpose: Returns vector of strings of attributes to search.
	****************************************************************************************************/
	std::vector<int> getAttributesToSearch();

	/****************************************************************************************************
	Name: getContentsToSearch
	Type: Method
	Purpose: Returns vector of strings of corresponding contents to search.
	****************************************************************************************************/
	std::vector<std::vector<std::string>> getContentsToSearch();
};
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\SearchCondition.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\support.cpp
	 */

bool support::checkStartEndTimeValidity(Date* startDate, Date* endDate) {
	if (startDate->getTimeT() > endDate->getTimeT()) {
		return false;
	}
	else {
		return true;
	}
	
	/*
	bool startEndTimeValidity = true;

	if (startDate->getYear() > endDate->getYear()) {
		startEndTimeValidity = false;
	} else if (startDate->getMonth() > endDate->getMonth()) {
		startEndTimeValidity = false;
	} else if (startDate->getDay() > endDate->getYear()) {
		startEndTimeValidity = false;
	} else if (startDate->getTime() > endDate->getTime()) {
		startEndTimeValidity = false;
	}

	return startEndTimeValidity;
	*/
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\support.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\support.cpp
	 */

bool support::isDateWithinTimeRange(Date* dateUnderExam, Date* timeRangeStart, Date* timeRangeEnd) {
	if (dateUnderExam->getTimeT() < timeRangeStart->getTimeT() || dateUnderExam->getTimeT() > timeRangeEnd->getTimeT()) {
		return false;
	}
	else {
		return true;
	}
}

bool support::isSpacesOnly(std::string& input) {
	while (input.substr(0,1)==" ") {
		if (input.size() <= 1) {
			return true;
		}
		input = input.substr(1);	
	}

	while (input.substr(input.size() - 1) == " ") {
		input = input.substr(0, input.size() - 1);
	}

	return false;
}

bool support::checkDateBefore(Date* dateToBeChecked, Date* dateToCheckWith) {
	if (dateToBeChecked->getTimeT() < dateToCheckWith->getTimeT()) {
		return true;
	}
	else {
		return false;
	}
}
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\support.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\support.h
	 */


#pragma once

#include "Date.h"
#include "keywords.h"
#include "Task.h"

#include <string>
#include <vector>
#include <algorithm>

namespace support {
	/*************************************************************************************************************
	Name: extractParamsForKeywords
	Type: support namespace method
	Purpose: Processes input string with given vector of keywords and extracts parameters for each keyword,
	Returns the parameters extracted as a vector of vector of strings, with the parameters extracted for each 
	keyword as a vector of strings assigned to its corresponding index element.
	**************************************************************************************************************/
	std::vector<std::vector<std::string>> extractParamsForKeywords(std::string&, std::vector<std::string>);
	
	/*************************************************************************************************************
	Name: prepareTaskDisplayAttributeBreakdown
	Type: support namespace method
	Purpose: Returns task type string according to:
	"TO-DO": Floating task type code - 1
	"DEADLINE": Deadline task type code - 2
	"EVENT": Partial-timed and Timed task type code - 3,4
	**************************************************************************************************************/
	std::string getTaskType(int taskTypeCode);
	
	/*************************************************************************************************************
	Name: checkStartEndTimeValidity
	Type: support namespace method
	Purpose: Checks and returns true of 2nd Date object time is bigger than 1st Date object time, false otherwise.
	**************************************************************************************************************/
	bool checkStartEndTimeValidity(Date*, Date*);
	
	/*************************************************************************************************************
	Name: prepareTaskDisplayAttributeBreakdown
	Type: support namespace method
	Purpose: Processes input task into task display string of the following format:
	Description: ...
	Start date/time: ...
	End date/time OR Deadline: ...
	Location: ...
	**************************************************************************************************************/
	std::string prepareTaskDisplayAttributeBreakdown(Task*);

	/*************************************************************************************************************
	Name: isTaskWithinTimeRange
	Type: support namespace method
	Purpose: Checks and returns true if input Task pointer is within specified start and end Date objects time 
	range, returns false otherwise.
	**************************************************************************************************************/
	bool isDateWithinTimeRange(Date*, Date*, Date*);
	
	/*************************************************************************************************************
	Name: isSpacesOnly
	Type: support namespace method
	Purpose: Checks and returns true if input reference string contains only spaces, returns false otherwise. Also
	trims any leading and ending spaces of input reference string. 
	**************************************************************************************************************/
	bool isSpacesOnly(std::string&);

	/*************************************************************************************************************
	Name: checkDateBefore
	Type: support namespace method
	Purpose: Checks and returns true if first input date is before second input date, returns false otherwise.
	**************************************************************************************************************/
	bool checkDateBefore(Date*, Date*);
}
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\support.h





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Task.cpp
	 */

int Task::getTaskTypeCode() {
	if ((_startDate == NULL) && (_endDate == NULL)) {
		return TASKTYPECODE_FLOATING;
	}
	if (_startDate == NULL) {
		return TASKTYPECODE_DEADLINE;
	}
	if (_endDate == NULL) {
		return TASKTYPECODE_PARTIALTIMED;
	}
	return TASKTYPECODE_TIMED;
}

// Gets the string of this task to be shown in the feedback box
std::string Task::toString() {
	std::string returnString = "";
	switch (getTaskTypeCode()) {
	case TASKTYPECODE_FLOATING:
		returnString += TASKTYPECODE_FLOATING;
		break;
	case TASKTYPECODE_DEADLINE:
		returnString += TASKTYPE_DEADLINE;
		break;
	case TASKTYPECODE_PARTIALTIMED:
		returnString += TASKTYPE_PARTIALTIMED;
		break;
	case TASKTYPECODE_TIMED:
		returnString += TASKTYPE_TIMED;
		break;
	} 
		
	returnString += " task - " + DESCRIPTION + ": \"" + _description + "\"";

	if (hasStartDate()) {
		returnString += "; " + STARTDATETIME + ": " + _startDate->toString();
	}

	if (hasEndDate()) {
		returnString += "; " + ENDDATETIME + ": " + _endDate->toString();
	}
	
	if (_location != "") {
		returnString += "; " + LOCATION + ": \"" + _location + "\"";
	}

	return returnString;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Task.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\TextStorage.cpp
	 */

void TextStorage::addTaskAtSpecificPosition(Task* newTask, int position) {
	_todoTasks->insert(_todoTasks->begin() + position - 1, newTask);
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\TextStorage.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\timeDateInfo.cpp
	 */

bool timeDateInfo::isMdayValid(std::string mdayInput, int month, int year) {
	if (!typeConversions::isNumber(mdayInput)) {
		return false;
	}

	int numDaysInMonth = timeDateInfo::getDaysInMonth(month - 1, year - 1900);

	if (typeConversions::stringToInt(mdayInput) < 1 || typeConversions::stringToInt(mdayInput) > numDaysInMonth) {
		return false;
	}

	return true;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\timeDateInfo.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\timeDateInfo.cpp
	 */

bool timeDateInfo::isDayValid(std::string dayInput, int& index) {
	bool isFound = false;

	for (int i = 0; i < 14; i++) {
		if (dayInput == DAYSINPUT[i]) {
			index = i;
			isFound = true;
		}
	}

	return isFound;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\timeDateInfo.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Undone.cpp
	 */

// Undone.cpp
// Implementation of functions in the Undone class

#include "Undone.h"

Undone::Undone() : Command() {
}

Undone::~Undone() {
}

void Undone::process(std::string argument) {
	if (support::isSpacesOnly(argument)) {
		throw exceptionInputInvalidSpacesOnly;
	}

	int numOfTasks = TextStorage::getInstance()->getNumberOfTasks();

	bool isProcessed = false;
	for (int i = 0; i < BEFOREKEYWORDSARRAYSIZE; i++) {
		int beforeKeywordPos = argument.find(BEFOREKEYWORDSARRAY[i]);
		if (beforeKeywordPos != std::string::npos) {
			if (isProcessed) {
				throw exceptionInputInvalidUndoneParams;
			}
			isProcessed = true;
			if (argument.find(BEFOREKEYWORDSARRAY[i]) != 0) {
				throw exceptionInputInvalidUndoneParams;
			}
			std::string dateString = argument.substr(BEFOREKEYWORDSARRAY[i].size());
			if (support::isSpacesOnly(dateString)) {
				throw exceptionInputInvalidSpacesOnly;
			}
			Date* date = new Date;
			if (!date->setDate(dateString)) {
				throw exceptionInputInvalidDateTimeAddEdit;
			}
			date->setTime(0);
			for (int j = 0; j < numOfTasks; j++) {
				Task* task = TextStorage::getInstance()->getTask(j);
				if (task->hasStartDate() && task->hasEndDate() || task->hasEndDate()) {
					if (support::checkDateBefore(task->getEndDate(), date)) {
						_undoneTasksIndexes.push_back(j + 1);
					}
				}
				else if (task->hasStartDate()) {
					if (support::checkDateBefore(task->getStartDate(), date)) {
						_undoneTasksIndexes.push_back(j + 1);
					}
				}
			}
		}
	}

	if (!isProcessed) {
		if (argument.find(ALLKEYWORD) != std::string::npos) {
			if (argument.find(ALLKEYWORD) > 0) {
				throw exceptionInputInvalidUndoneParams;
			}
			for (int i = 0; i < numOfTasks; i++) {
				_undoneTasksIndexes.push_back(i + 1);
			}
		}
		else {
			int nextSpacePos = argument.find(" ");
			while (nextSpacePos != std::string::npos) {
				std::string taskIndexString = argument.substr(0, nextSpacePos);
				if (!typeConversions::isNumber(taskIndexString)) {
					throw exceptionInputInvalidTaskIndex;
				}
				int taskIndex = typeConversions::stringToInt(taskIndexString);
				if (taskIndex < 1 || taskIndex > numOfTasks) {
					throw exceptionInputInvalidTaskIndex;
				}
				_undoneTasksIndexes.push_back(taskIndex);
				argument = argument.substr(nextSpacePos + 1);
				support::isSpacesOnly(argument);
				nextSpacePos = argument.find(" ");
			}

			if (!typeConversions::isNumber(argument)) {
				throw exceptionInputInvalidTaskIndex;
			}
			_undoneTasksIndexes.push_back(typeConversions::stringToInt(argument));
		}
	}

	std::sort(_undoneTasksIndexes.begin(), _undoneTasksIndexes.end());

	return;
}

std::string Undone::execute(std::string argument) {
	// Formats:
	// 1. Undone single task
	//    - undone 1
	// 2. Undone multiple tasks
	//    - undone 1 2 3
	// 3. Undone all tasks before date
	//    - undone before 22/12/14
	//    - undone .b 22/12/14

	std::string feedback = "Marked incomplete task(s): ";

	process(argument);

	for (unsigned int i = 0; i < _undoneTasksIndexes.size(); i++) {
		if (TextStorage::getInstance()->getTask(_undoneTasksIndexes[i] - 1) != NULL) {
			_undoneTasks.push_back(TextStorage::getInstance()->getTask(_undoneTasksIndexes[i] - 1));
			TextStorage::getInstance()->getTask(_undoneTasksIndexes[i] - 1)->undone();
			feedback += "(" + typeConversions::intToString(_undoneTasksIndexes[i]) + ")";
			if (i < _undoneTasksIndexes.size() - 1) {
				feedback += ", ";
			}
			else {
				feedback += ".";
			}
		}
		else {
			ErrorLog::inputErrorLog("Unsuccessful undone, please check undone class.");
			assert(TextStorage::getInstance()->getTask(_undoneTasksIndexes[i] - 1) != NULL);
		}
	}

	return feedback;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Undone.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Undone.cpp
	 */

std::string Undone::undo() {
	std::string feedback = "Undo undone: Marked complete task(s): ";

	for (unsigned int i = 0; i < _undoneTasks.size(); i++) {
		_undoneTasks[i]->done();
		feedback += "(" + typeConversions::intToString(_undoneTasksIndexes[i]) + ")";
		if (i < _undoneTasksIndexes.size() - 1) {
			feedback += ", ";
		}
		else {
			feedback += ".";
		}
	}

	return feedback;
}

std::string Undone::redo() {
	std::string feedback = "Redo undone: Marked incomplete task(s): ";

	for (unsigned int i = 0; i < _undoneTasks.size(); i++) {
		_undoneTasks[i]->undone();
		feedback += "(" + typeConversions::intToString(_undoneTasksIndexes[i]) + ")";
		if (i < _undoneTasksIndexes.size() - 1) {
			feedback += ", ";
		}
		else {
			feedback += ".";
		}
	}

	return feedback;
}

	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Undone.cpp





	/**
	 * origin: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Undone.h
	 */

// Undone.h
// Subclass of Command; implements the undone function

#pragma once

#include "Command.h"
#include "typeConversions.h"
#include "TextStorage.h"
#include "Exceptions.h"
#include "support.h"

#include <vector>
#include <algorithm>

class Undone : public Command {
private:
	std::vector<int> _undoneTasksIndexes;
	std::vector<Task*> _undoneTasks;

	void process(std::string);
	bool checkDateBefore(Date*, Date*);

public:
	Undone();
	~Undone();
	std::string execute(std::string argument);
	std::string undo();
	std::string redo();
};
	// End of segment: C:\Users\RachH\Desktop\120315-ComCal\ComCal_v0.1\Undone.h





